# 版本号管理

## 语义化版本

- 标准版本号格式：
  `[主版本号].[次版本号].[修订号]`
  `[MAJOR].[MINOR].[PATCH]`
- 版本号变更基本递增规则：
  1. 主版本号递增：做了不兼容的更改
  2. 次版本号递增：做了向下兼容的功能性修改/新增
  3. 修订号：做了向下兼容的问题修正
  4.  先行版本号及版本编译信息可以加到版本号尾部作为版本号的延伸
- 语义化版本针对的问题：
    “依赖地狱”： 系统规模越大，加入的包越多，在高依赖的系统中发布新版本，可能面临版本控制被锁死的风险或版本混乱的问题。
    语义化版本通过修改相应的版本号来说明修改。
## 语义化版本控制规范

1. 使用语义化版本控制的软件必须定义公共API。该API可以在代码中被定义或出现于严谨的文档内，无论何种形式都应该力求精确且完整。

3. 标准的版本好必须采用X.Y.Z的格式，其中X、Y、Z为非负的整数，且禁止在数字前方补零。每个元素必须以数值来递增。

4. 标记版本号的软件发布后，禁止改变该版本的内容。任何修改都必须以新版本发布。

5. 主版本号为0的软件处于开发初始阶段，一切都可能被随时改变。不应该被视为稳定版本

6. 1.0.0 的版本号用于界定公共API的形成。这一版本后的版本号更新都基于公共API及其修改内容。

7. 修订号Z只在做了向下兼容的修正时才递增。这里的递增指针对不正确结果而进行的内部修改。

8. 次版本号Y必须在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须递增。也可以在内部程序有大量新功能或改进被加入时递增，其中可以包括修订级别的改变。每当次版本号递增时，修订号必须归零。

9. 主版本号 X（X.y.z `|` X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须归零。

10. 先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。

11. 版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。

12. 版本的优先层级指的是不同版本在排序时如何比较。
    
    1.  判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。
        
    2.  由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。
        
        例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
        
    3.  当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。
        
        例如：1.0.0-alpha < 1.0.0。
        
    4.  有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：
        
        1.  只有数字的标识符以数值高低比较。
            
        2.  有字母或连接号时则逐字以 ASCII 的排序来比较。
            
        3.  数字的标识符比非数字的标识符优先层级低。
            
        4.  若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。
            
  例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。

## npm 中的version管理
基本命令行：

```shell
npm version [<newversion> | major | minor | patch | premajor | preminor | prepatch | prerelease [ --preid=<prerelease-id> ] | from-git]
npm [-v | --version] # to print npm version
npm view <pkg> version # to view a package's published version
npm ls #to inspect current package/dependency versions
```

| 选项       | 描述                                       | 例子                     | 说明                                      |
| ---------- | ------------------------------------------ | ------------------------ | ----------------------------------------- |
| major      | 重大更新版本                               | `npm version major`      | 0.2.0 =》1.0.0                            |
| minor      | 主要版本更新                               | `npm version minor`      | 0.2.0 =》0.3.0                            |
| patch      | 补丁更新版本                               | `npm version patch`      | 0.2.0 =》0.2.1                            |
| premajor   | 重大版本更新预发布版本                     | `npm version premajor`   | 0.2.0 =》1.0.0-0                          |
| preminor   | 主要版本更新预发布版本                     | `npm version preminor`   | 0.2.0 =》0.3.0-0                          |
| prepatch   | 补丁更新版本预发布版本                     | `npm version prepatch`   | 0.2.0 =》0.2.1-0                          |
| prerelease | 预发布版本                                 | `npm version prerelease` | 当前版本不是预发布版本的会出错            |
| from-git   | 拿取git的tag作为版本号设置至package.json内 | `npm version from-git`   | git的tag标签没有设置的情况下，会抛出错误 |

关于prerelease的使用是存在前提。当前版本必须是预发布版本，如果不是预发布版本是会抛出错误的，使用时需要注意。使用[--preid]提供额外参数还可用于详细描述预发布版本的作用，比如需要实现下面这种情况：

```shell
# 更新为预发布版本号
$ npm version premajor --preid beta
v1.0.0-beta.0
```

version 命令会同时在git上打上版本号的tag，自定义提交描述(默认提交描述为版本号)可如下：
```shell
$ npm version major -m "版本更新至%s"

```

不进行git操作：
```shell
# 更新至新的补丁版本，并不增加git的tag
$ npm version patch --no-git-tag-version
```



